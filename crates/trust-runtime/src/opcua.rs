//! OPC UA interoperability profile and IEC type mapping helpers.

#![allow(missing_docs)]

use std::path::Path;
use std::sync::Arc;

use smol_str::SmolStr;

use crate::debug::DebugSnapshot;
use crate::error::RuntimeError;
use crate::value::Value;

#[cfg(feature = "opcua-wire")]
use ::opcua::client::prelude::{AttributeService, ViewService};
#[cfg(feature = "opcua-wire")]
use glob::Pattern;
#[cfg(feature = "opcua-wire")]
use std::collections::HashMap;
#[cfg(feature = "opcua-wire")]
use std::path::PathBuf;
#[cfg(feature = "opcua-wire")]
use std::time::{Duration as StdDuration, Instant};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum OpcUaSecurityPolicy {
    None,
    Basic256Sha256,
    Aes128Sha256RsaOaep,
}

impl OpcUaSecurityPolicy {
    #[must_use]
    pub fn parse(text: &str) -> Option<Self> {
        let normalized = text.trim().to_ascii_lowercase().replace(['-', '_'], "");
        match normalized.as_str() {
            "none" => Some(Self::None),
            "basic256sha256" => Some(Self::Basic256Sha256),
            "aes128sha256rsaoaep" => Some(Self::Aes128Sha256RsaOaep),
            _ => None,
        }
    }

    #[must_use]
    pub fn as_config_value(self) -> &'static str {
        match self {
            Self::None => "none",
            Self::Basic256Sha256 => "basic256sha256",
            Self::Aes128Sha256RsaOaep => "aes128sha256rsaoaep",
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum OpcUaMessageSecurityMode {
    None,
    Sign,
    SignAndEncrypt,
}

impl OpcUaMessageSecurityMode {
    #[must_use]
    pub fn parse(text: &str) -> Option<Self> {
        let normalized = text.trim().to_ascii_lowercase().replace(['-', '_'], "");
        match normalized.as_str() {
            "none" => Some(Self::None),
            "sign" => Some(Self::Sign),
            "signandencrypt" => Some(Self::SignAndEncrypt),
            _ => None,
        }
    }

    #[must_use]
    pub fn as_config_value(self) -> &'static str {
        match self {
            Self::None => "none",
            Self::Sign => "sign",
            Self::SignAndEncrypt => "sign_and_encrypt",
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct OpcUaSecurityProfile {
    pub policy: OpcUaSecurityPolicy,
    pub mode: OpcUaMessageSecurityMode,
    pub allow_anonymous: bool,
}

impl Default for OpcUaSecurityProfile {
    fn default() -> Self {
        Self {
            policy: OpcUaSecurityPolicy::Basic256Sha256,
            mode: OpcUaMessageSecurityMode::SignAndEncrypt,
            allow_anonymous: false,
        }
    }
}

#[derive(Debug, Clone)]
pub struct OpcUaRuntimeConfig {
    pub enabled: bool,
    pub listen: SmolStr,
    pub endpoint_path: SmolStr,
    pub namespace_uri: SmolStr,
    pub publish_interval_ms: u64,
    pub max_nodes: usize,
    pub expose: Vec<SmolStr>,
    pub security: OpcUaSecurityProfile,
    pub username: Option<SmolStr>,
    pub password: Option<SmolStr>,
}

impl Default for OpcUaRuntimeConfig {
    fn default() -> Self {
        Self {
            enabled: false,
            listen: SmolStr::new("0.0.0.0:4840"),
            endpoint_path: SmolStr::new("/"),
            namespace_uri: SmolStr::new("urn:trust:runtime"),
            publish_interval_ms: 250,
            max_nodes: 128,
            expose: Vec::new(),
            security: OpcUaSecurityProfile::default(),
            username: None,
            password: None,
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum OpcUaDataType {
    Boolean,
    Int16,
    Int32,
    Int64,
    UInt16,
    UInt32,
    UInt64,
    Float,
    Double,
    String,
}

#[derive(Debug, Clone, PartialEq)]
pub enum OpcUaVariant {
    Boolean(bool),
    Int16(i16),
    Int32(i32),
    Int64(i64),
    UInt16(u16),
    UInt32(u32),
    UInt64(u64),
    Float(f32),
    Double(f64),
    String(String),
}

#[derive(Debug, Clone, PartialEq)]
pub struct OpcUaValue {
    pub data_type: OpcUaDataType,
    pub value: OpcUaVariant,
}

#[derive(Debug, Clone)]
pub struct OpcUaExposedNode {
    pub name: SmolStr,
    pub node_id: String,
    pub data_type: OpcUaDataType,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum OpcUaClientIdentity<'a> {
    Anonymous,
    UserName {
        username: &'a str,
        password: &'a str,
    },
}

#[derive(Debug, Clone, Copy)]
pub struct OpcUaClientOptions {
    pub trust_server_certificate: bool,
}

impl Default for OpcUaClientOptions {
    fn default() -> Self {
        Self {
            trust_server_certificate: true,
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct OpcUaLoadReport {
    pub iterations: usize,
    pub browse_ok: usize,
    pub read_ok: usize,
    pub write_ok: usize,
    pub elapsed_ms: u128,
}

pub struct OpcUaWireServer {
    endpoint_url: String,
    security: OpcUaSecurityProfile,
    exposed_nodes: Vec<OpcUaExposedNode>,
    #[cfg(feature = "opcua-wire")]
    node_ids: HashMap<SmolStr, ::opcua::types::NodeId>,
    #[cfg(feature = "opcua-wire")]
    client_pki_dir: PathBuf,
    #[cfg(feature = "opcua-wire")]
    server: Arc<::opcua::sync::RwLock<::opcua::server::prelude::Server>>,
    #[cfg(feature = "opcua-wire")]
    server_thread: Option<std::thread::JoinHandle<()>>,
}

impl std::fmt::Debug for OpcUaWireServer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("OpcUaWireServer")
            .field("endpoint_url", &self.endpoint_url)
            .field("security", &self.security)
            .field("exposed_nodes", &self.exposed_nodes)
            .finish()
    }
}

impl Drop for OpcUaWireServer {
    fn drop(&mut self) {
        self.stop();
    }
}

impl OpcUaWireServer {
    #[must_use]
    pub fn endpoint_url(&self) -> &str {
        self.endpoint_url.as_str()
    }

    #[must_use]
    pub fn security_profile(&self) -> OpcUaSecurityProfile {
        self.security
    }

    #[must_use]
    pub fn exposed_nodes(&self) -> &[OpcUaExposedNode] {
        self.exposed_nodes.as_slice()
    }

    #[cfg(feature = "opcua-wire")]
    pub fn stop(&mut self) {
        if let Some(join) = self.server_thread.take() {
            self.server.write().abort();
            let _ = join.join();
        }
    }

    #[cfg(not(feature = "opcua-wire"))]
    pub fn stop(&mut self) {}

    #[cfg(feature = "opcua-wire")]
    pub fn probe_read(
        &self,
        node_name: &str,
        identity: OpcUaClientIdentity<'_>,
    ) -> Result<OpcUaVariant, RuntimeError> {
        self.probe_read_with_options(node_name, identity, OpcUaClientOptions::default())
    }

    #[cfg(not(feature = "opcua-wire"))]
    pub fn probe_read(
        &self,
        _node_name: &str,
        _identity: OpcUaClientIdentity<'_>,
    ) -> Result<OpcUaVariant, RuntimeError> {
        Err(opcua_wire_feature_error())
    }

    #[cfg(feature = "opcua-wire")]
    pub fn probe_read_with_options(
        &self,
        node_name: &str,
        identity: OpcUaClientIdentity<'_>,
        options: OpcUaClientOptions,
    ) -> Result<OpcUaVariant, RuntimeError> {
        let node_id = self.node_id(node_name)?;
        let session = self.connect_session(identity, options)?;
        let value = {
            let session_guard = session.read();
            let values = session_guard
                .read(
                    &[::opcua::types::ReadValueId::from(node_id)],
                    ::opcua::types::TimestampsToReturn::Both,
                    0.0,
                )
                .map_err(opcua_status_error)?;
            values
                .into_iter()
                .next()
                .and_then(|item| item.value)
                .ok_or_else(|| RuntimeError::ControlError("OPC UA read returned no value".into()))?
        };
        session.read().disconnect();
        from_wire_variant(&value).ok_or_else(|| {
            RuntimeError::ControlError(format!("unsupported OPC UA variant: {value:?}").into())
        })
    }

    #[cfg(not(feature = "opcua-wire"))]
    pub fn probe_read_with_options(
        &self,
        _node_name: &str,
        _identity: OpcUaClientIdentity<'_>,
        _options: OpcUaClientOptions,
    ) -> Result<OpcUaVariant, RuntimeError> {
        Err(opcua_wire_feature_error())
    }

    #[cfg(feature = "opcua-wire")]
    pub fn run_load_fixture(
        &self,
        node_name: &str,
        iterations: usize,
        identity: OpcUaClientIdentity<'_>,
        options: OpcUaClientOptions,
    ) -> Result<OpcUaLoadReport, RuntimeError> {
        let node_id = self.node_id(node_name)?;
        let session = self.connect_session(identity, options)?;
        let start = Instant::now();
        let mut browse_ok = 0usize;
        let mut read_ok = 0usize;
        let mut write_ok = 0usize;

        {
            let session_guard = session.read();
            for _ in 0..iterations {
                let browse = session_guard
                    .browse(&[::opcua::types::BrowseDescription {
                        node_id: ::opcua::types::NodeId::objects_folder_id(),
                        browse_direction: ::opcua::types::BrowseDirection::Forward,
                        reference_type_id: ::opcua::types::ReferenceTypeId::References.into(),
                        include_subtypes: true,
                        node_class_mask: ::opcua::types::NodeClassMask::all().bits(),
                        result_mask: ::opcua::types::BrowseDescriptionResultMask::all().bits(),
                    }])
                    .map_err(opcua_status_error)?;
                if browse.is_some() {
                    browse_ok += 1;
                }

                let values = session_guard
                    .read(
                        &[::opcua::types::ReadValueId::from(node_id.clone())],
                        ::opcua::types::TimestampsToReturn::Both,
                        0.0,
                    )
                    .map_err(opcua_status_error)?;
                let Some(value) = values.first().and_then(|item| item.value.clone()) else {
                    continue;
                };
                read_ok += 1;

                let write_result = session_guard
                    .write(&[::opcua::types::WriteValue {
                        node_id: node_id.clone(),
                        attribute_id: ::opcua::types::AttributeId::Value as u32,
                        index_range: ::opcua::types::UAString::null(),
                        value: ::opcua::types::DataValue {
                            value: Some(value),
                            status: Some(::opcua::types::StatusCode::Good),
                            source_timestamp: Some(::opcua::types::DateTime::now()),
                            ..Default::default()
                        },
                    }])
                    .map_err(opcua_status_error)?;
                if write_result
                    .first()
                    .is_some_and(::opcua::types::StatusCode::is_good)
                {
                    write_ok += 1;
                }
            }
        }

        session.read().disconnect();
        Ok(OpcUaLoadReport {
            iterations,
            browse_ok,
            read_ok,
            write_ok,
            elapsed_ms: start.elapsed().as_millis(),
        })
    }

    #[cfg(not(feature = "opcua-wire"))]
    pub fn run_load_fixture(
        &self,
        _node_name: &str,
        _iterations: usize,
        _identity: OpcUaClientIdentity<'_>,
        _options: OpcUaClientOptions,
    ) -> Result<OpcUaLoadReport, RuntimeError> {
        Err(opcua_wire_feature_error())
    }

    #[cfg(feature = "opcua-wire")]
    fn connect_session(
        &self,
        identity: OpcUaClientIdentity<'_>,
        options: OpcUaClientOptions,
    ) -> Result<Arc<::opcua::sync::RwLock<::opcua::client::prelude::Session>>, RuntimeError> {
        let client_pki_dir = if options.trust_server_certificate {
            self.client_pki_dir.clone()
        } else {
            self.client_pki_dir.join("strict")
        };
        std::fs::create_dir_all(&client_pki_dir).map_err(|err| {
            RuntimeError::ControlError(format!("create OPC UA client PKI: {err}").into())
        })?;

        let mut client = ::opcua::client::prelude::ClientBuilder::new()
            .application_name("truST OPC UA probe")
            .application_uri("urn:trust:runtime:opcua:probe")
            .product_uri("urn:trust:runtime")
            .pki_dir(client_pki_dir)
            .create_sample_keypair(true)
            .trust_server_certs(options.trust_server_certificate)
            .verify_server_certs(!options.trust_server_certificate)
            .session_retry_limit(1)
            .client()
            .ok_or_else(|| RuntimeError::ControlError("failed to build OPC UA client".into()))?;

        let security_policy = to_wire_security_policy(self.security.policy);
        let security_mode = to_wire_security_mode(self.security.mode);
        let endpoints = client
            .get_server_endpoints_from_url(self.endpoint_url.as_str())
            .map_err(opcua_status_error)?;
        let endpoint = ::opcua::client::prelude::Client::find_matching_endpoint(
            endpoints.as_slice(),
            self.endpoint_url.as_str(),
            security_policy,
            security_mode,
        )
        .ok_or_else(|| {
            RuntimeError::ControlError(
                format!(
                    "no matching OPC UA endpoint for {} / {:?}",
                    security_policy.to_uri(),
                    security_mode
                )
                .into(),
            )
        })?;
        let token = match identity {
            OpcUaClientIdentity::Anonymous => ::opcua::client::prelude::IdentityToken::Anonymous,
            OpcUaClientIdentity::UserName { username, password } => {
                ::opcua::client::prelude::IdentityToken::UserName(
                    username.to_string(),
                    password.to_string(),
                )
            }
        };
        client
            .connect_to_endpoint(endpoint, token)
            .map_err(opcua_status_error)
    }

    #[cfg(feature = "opcua-wire")]
    fn node_id(&self, node_name: &str) -> Result<::opcua::types::NodeId, RuntimeError> {
        self.node_ids.get(node_name).cloned().ok_or_else(|| {
            RuntimeError::ControlError(format!("unknown OPC UA node '{node_name}'").into())
        })
    }
}

#[cfg(not(feature = "opcua-wire"))]
fn opcua_wire_feature_error() -> RuntimeError {
    RuntimeError::ControlError(
        "OPC UA wire support is disabled in this build (enable feature 'opcua-wire')".into(),
    )
}

#[must_use]
pub fn map_iec_value(value: &Value) -> Option<OpcUaValue> {
    match value {
        Value::Bool(value) => Some(OpcUaValue {
            data_type: OpcUaDataType::Boolean,
            value: OpcUaVariant::Boolean(*value),
        }),
        Value::Int(value) => Some(OpcUaValue {
            data_type: OpcUaDataType::Int16,
            value: OpcUaVariant::Int16(*value),
        }),
        Value::DInt(value) => Some(OpcUaValue {
            data_type: OpcUaDataType::Int32,
            value: OpcUaVariant::Int32(*value),
        }),
        Value::LInt(value) => Some(OpcUaValue {
            data_type: OpcUaDataType::Int64,
            value: OpcUaVariant::Int64(*value),
        }),
        Value::UInt(value) => Some(OpcUaValue {
            data_type: OpcUaDataType::UInt16,
            value: OpcUaVariant::UInt16(*value),
        }),
        Value::UDInt(value) => Some(OpcUaValue {
            data_type: OpcUaDataType::UInt32,
            value: OpcUaVariant::UInt32(*value),
        }),
        Value::ULInt(value) => Some(OpcUaValue {
            data_type: OpcUaDataType::UInt64,
            value: OpcUaVariant::UInt64(*value),
        }),
        Value::Real(value) => Some(OpcUaValue {
            data_type: OpcUaDataType::Float,
            value: OpcUaVariant::Float(*value),
        }),
        Value::LReal(value) => Some(OpcUaValue {
            data_type: OpcUaDataType::Double,
            value: OpcUaVariant::Double(*value),
        }),
        Value::String(value) => Some(OpcUaValue {
            data_type: OpcUaDataType::String,
            value: OpcUaVariant::String(value.to_string()),
        }),
        Value::WString(value) => Some(OpcUaValue {
            data_type: OpcUaDataType::String,
            value: OpcUaVariant::String(value.clone()),
        }),
        Value::Char(value) => Some(OpcUaValue {
            data_type: OpcUaDataType::String,
            value: OpcUaVariant::String(char::from(*value).to_string()),
        }),
        Value::WChar(value) => char::from_u32(u32::from(*value)).map(|ch| OpcUaValue {
            data_type: OpcUaDataType::String,
            value: OpcUaVariant::String(ch.to_string()),
        }),
        Value::SInt(value) => Some(OpcUaValue {
            data_type: OpcUaDataType::Int16,
            value: OpcUaVariant::Int16(i16::from(*value)),
        }),
        Value::USInt(value) => Some(OpcUaValue {
            data_type: OpcUaDataType::UInt16,
            value: OpcUaVariant::UInt16(u16::from(*value)),
        }),
        Value::Byte(value) => Some(OpcUaValue {
            data_type: OpcUaDataType::UInt16,
            value: OpcUaVariant::UInt16(u16::from(*value)),
        }),
        Value::Word(value) => Some(OpcUaValue {
            data_type: OpcUaDataType::UInt16,
            value: OpcUaVariant::UInt16(*value),
        }),
        Value::DWord(value) => Some(OpcUaValue {
            data_type: OpcUaDataType::UInt32,
            value: OpcUaVariant::UInt32(*value),
        }),
        Value::LWord(value) => Some(OpcUaValue {
            data_type: OpcUaDataType::UInt64,
            value: OpcUaVariant::UInt64(*value),
        }),
        _ => None,
    }
}

#[cfg(feature = "opcua-wire")]
pub fn start_wire_server(
    resource_name: &str,
    config: &OpcUaRuntimeConfig,
    snapshot_provider: Arc<dyn Fn() -> Option<DebugSnapshot> + Send + Sync>,
    runtime_root: Option<&Path>,
) -> Result<Option<OpcUaWireServer>, RuntimeError> {
    if !config.enabled {
        return Ok(None);
    }
    validate_security_profile(&config.security)?;
    let (bind_host, bind_port) = parse_listen(config.listen.as_str())?;
    let endpoint_path = normalize_endpoint_path(config.endpoint_path.as_str())?;
    let connect_host = if bind_host == "0.0.0.0" || bind_host == "::" {
        "127.0.0.1".to_string()
    } else {
        bind_host.clone()
    };
    let endpoint_url = format!("opc.tcp://{connect_host}:{bind_port}{endpoint_path}");
    let pki_root = runtime_root
        .map(|root| root.join("security").join("opcua"))
        .unwrap_or_else(|| std::env::temp_dir().join("trust-runtime-opcua"));
    let server_pki_dir = pki_root.join("server");
    let client_pki_dir = pki_root.join("client");
    std::fs::create_dir_all(&server_pki_dir).map_err(|err| {
        RuntimeError::ControlError(format!("create OPC UA server PKI: {err}").into())
    })?;
    std::fs::create_dir_all(&client_pki_dir).map_err(|err| {
        RuntimeError::ControlError(format!("create OPC UA client PKI: {err}").into())
    })?;

    let initial_snapshot = snapshot_provider().ok_or_else(|| {
        RuntimeError::ControlError("runtime snapshot unavailable for OPC UA startup".into())
    })?;
    let candidates = collect_exposed_nodes(&initial_snapshot, config)?;
    let (user_token_ids, user_credentials) = user_tokens(config)?;
    let mut builder = ::opcua::server::prelude::ServerBuilder::new()
        .application_name(format!("truST Runtime {resource_name}"))
        .application_uri(format!("urn:trust:runtime:{resource_name}"))
        .product_uri("urn:trust:runtime")
        .create_sample_keypair(true)
        .pki_dir(server_pki_dir.clone())
        .trust_client_certs()
        .host_and_port(bind_host.clone(), bind_port)
        .discovery_urls(vec![endpoint_url.clone()])
        .endpoint(
            "trust-runtime",
            build_server_endpoint(endpoint_path.as_str(), config.security, &user_token_ids)?,
        );
    if let Some((username, password)) = user_credentials {
        builder = builder.user_token(
            "runtime_user",
            ::opcua::server::prelude::ServerUserToken::user_pass(username, password),
        );
    }
    let mut server = builder.server().ok_or_else(|| {
        RuntimeError::ControlError("failed to create OPC UA server from runtime profile".into())
    })?;

    let address_space = server.address_space();
    let mut node_ids = HashMap::<SmolStr, ::opcua::types::NodeId>::new();
    let mut exposed_nodes = Vec::<OpcUaExposedNode>::new();
    {
        let mut address_space_guard = ::opcua::trace_write_lock!(address_space);
        let namespace = address_space_guard
            .register_namespace(config.namespace_uri.as_str())
            .map_err(|_| {
                RuntimeError::ControlError("failed to register OPC UA namespace".into())
            })?;
        let folder_id = address_space_guard
            .add_folder(
                "truST",
                "truST",
                &::opcua::types::NodeId::objects_folder_id(),
            )
            .map_err(|_| {
                RuntimeError::ControlError("failed to create OPC UA root folder".into())
            })?;
        let mut variables = Vec::new();
        for node in candidates {
            let ExposedNodeCandidate {
                name,
                data_type,
                value,
            } = node;
            let browse_name = name.to_string();
            let node_id = ::opcua::types::NodeId::new(namespace, browse_name.clone());
            let mut variable = ::opcua::server::prelude::Variable::new(
                &node_id,
                browse_name.as_str(),
                browse_name.as_str(),
                to_wire_variant(&value),
            );
            variable.set_writable(true);
            variable.set_user_access_level(
                variable.user_access_level()
                    | ::opcua::server::prelude::UserAccessLevel::CURRENT_WRITE,
            );
            variables.push(variable);
            node_ids.insert(name.clone(), node_id.clone());
            exposed_nodes.push(OpcUaExposedNode {
                name,
                node_id: node_id.to_string(),
                data_type,
            });
        }
        if !variables.is_empty() {
            let added = address_space_guard.add_variables(variables, &folder_id);
            if added.iter().any(|inserted| !*inserted) {
                return Err(RuntimeError::ControlError(
                    "failed to publish OPC UA variables".into(),
                ));
            }
        }
    }

    if !node_ids.is_empty() {
        let refresh_space = address_space.clone();
        let refresh_nodes = node_ids.clone();
        let refresh_snapshot = snapshot_provider.clone();
        server.add_polling_action(config.publish_interval_ms, move || {
            let Some(snapshot) = refresh_snapshot() else {
                return;
            };
            let now = ::opcua::types::DateTime::now();
            let mut address_space_guard = ::opcua::trace_write_lock!(refresh_space);
            for (name, node_id) in &refresh_nodes {
                let Some(value) = snapshot.storage.get_global(name.as_str()) else {
                    continue;
                };
                let Some(mapped) = map_iec_value(value) else {
                    continue;
                };
                address_space_guard.set_variable_value(
                    node_id.clone(),
                    to_wire_variant(&mapped.value),
                    &now,
                    &now,
                );
            }
        });
    }

    let server = Arc::new(::opcua::sync::RwLock::new(server));
    let server_task = server.clone();
    let server_thread = std::thread::Builder::new()
        .name("trust-runtime-opcua".to_string())
        .spawn(move || {
            ::opcua::server::prelude::Server::run_server(server_task);
        })
        .map_err(|err| RuntimeError::ThreadSpawn(format!("OPC UA server thread: {err}").into()))?;

    wait_for_endpoint(connect_host.as_str(), bind_port, StdDuration::from_secs(4))?;
    let wire_server = OpcUaWireServer {
        endpoint_url,
        security: config.security,
        exposed_nodes,
        node_ids,
        client_pki_dir,
        server,
        server_thread: Some(server_thread),
    };

    if let Some(node) = wire_server.exposed_nodes.first() {
        let identity = if config.security.allow_anonymous {
            OpcUaClientIdentity::Anonymous
        } else if let (Some(username), Some(password)) =
            (config.username.as_ref(), config.password.as_ref())
        {
            OpcUaClientIdentity::UserName { username, password }
        } else {
            return Err(RuntimeError::ControlError(
                "OPC UA startup probe requires runtime.opcua.username/password".into(),
            ));
        };
        wire_server.probe_read(node.name.as_str(), identity)?;
    }

    Ok(Some(wire_server))
}

#[cfg(not(feature = "opcua-wire"))]
pub fn start_wire_server(
    _resource_name: &str,
    config: &OpcUaRuntimeConfig,
    _snapshot_provider: Arc<dyn Fn() -> Option<DebugSnapshot> + Send + Sync>,
    _runtime_root: Option<&Path>,
) -> Result<Option<OpcUaWireServer>, RuntimeError> {
    if !config.enabled {
        return Ok(None);
    }
    Err(opcua_wire_feature_error())
}

#[cfg(feature = "opcua-wire")]
#[derive(Debug, Clone)]
struct ExposedNodeCandidate {
    name: SmolStr,
    data_type: OpcUaDataType,
    value: OpcUaVariant,
}

#[cfg(feature = "opcua-wire")]
fn collect_exposed_nodes(
    snapshot: &DebugSnapshot,
    config: &OpcUaRuntimeConfig,
) -> Result<Vec<ExposedNodeCandidate>, RuntimeError> {
    let patterns = compile_exposure_patterns(config.expose.as_slice())?;
    let mut nodes = Vec::new();
    for (name, value) in snapshot.storage.globals() {
        if !patterns.is_empty()
            && !patterns
                .iter()
                .any(|pattern| pattern.matches(name.as_str()))
        {
            continue;
        }
        let Some(mapped) = map_iec_value(value) else {
            continue;
        };
        nodes.push(ExposedNodeCandidate {
            name: name.clone(),
            data_type: mapped.data_type,
            value: mapped.value,
        });
        if nodes.len() >= config.max_nodes {
            break;
        }
    }
    Ok(nodes)
}

#[cfg(feature = "opcua-wire")]
fn compile_exposure_patterns(patterns: &[SmolStr]) -> Result<Vec<Pattern>, RuntimeError> {
    patterns
        .iter()
        .map(|pattern| {
            Pattern::new(pattern.as_str()).map_err(|err| {
                RuntimeError::InvalidConfig(
                    format!("runtime.opcua.expose invalid pattern '{}': {err}", pattern).into(),
                )
            })
        })
        .collect()
}

#[cfg(feature = "opcua-wire")]
type OpcUaUserTokens = (Vec<String>, Option<(String, String)>);

#[cfg(feature = "opcua-wire")]
fn user_tokens(config: &OpcUaRuntimeConfig) -> Result<OpcUaUserTokens, RuntimeError> {
    let mut user_token_ids = Vec::<String>::new();
    if config.security.allow_anonymous {
        user_token_ids.push(::opcua::server::prelude::ANONYMOUS_USER_TOKEN_ID.to_string());
    }
    let credentials = match (config.username.as_ref(), config.password.as_ref()) {
        (Some(username), Some(password)) => {
            user_token_ids.push("runtime_user".to_string());
            Some((username.to_string(), password.to_string()))
        }
        (None, None) => None,
        _ => {
            return Err(RuntimeError::InvalidConfig(
                "runtime.opcua.username/password must both be set or both be omitted".into(),
            ))
        }
    };
    if user_token_ids.is_empty() {
        return Err(RuntimeError::InvalidConfig(
            "runtime.opcua must allow anonymous or configure username/password".into(),
        ));
    }
    Ok((user_token_ids, credentials))
}

#[cfg(feature = "opcua-wire")]
fn build_server_endpoint(
    endpoint_path: &str,
    security: OpcUaSecurityProfile,
    user_token_ids: &[String],
) -> Result<::opcua::server::prelude::ServerEndpoint, RuntimeError> {
    let endpoint = match (security.policy, security.mode) {
        (OpcUaSecurityPolicy::None, OpcUaMessageSecurityMode::None) => {
            ::opcua::server::prelude::ServerEndpoint::new_none(endpoint_path, user_token_ids)
        }
        (OpcUaSecurityPolicy::Basic256Sha256, OpcUaMessageSecurityMode::Sign) => {
            ::opcua::server::prelude::ServerEndpoint::new_basic256sha256_sign(
                endpoint_path,
                user_token_ids,
            )
        }
        (OpcUaSecurityPolicy::Basic256Sha256, OpcUaMessageSecurityMode::SignAndEncrypt) => {
            ::opcua::server::prelude::ServerEndpoint::new_basic256sha256_sign_encrypt(
                endpoint_path,
                user_token_ids,
            )
        }
        (OpcUaSecurityPolicy::Aes128Sha256RsaOaep, OpcUaMessageSecurityMode::Sign) => {
            ::opcua::server::prelude::ServerEndpoint::new_aes128_sha256_rsaoaep_sign(
                endpoint_path,
                user_token_ids,
            )
        }
        (OpcUaSecurityPolicy::Aes128Sha256RsaOaep, OpcUaMessageSecurityMode::SignAndEncrypt) => {
            ::opcua::server::prelude::ServerEndpoint::new_aes128_sha256_rsaoaep_sign_encrypt(
                endpoint_path,
                user_token_ids,
            )
        }
        (policy, mode) => {
            return Err(RuntimeError::InvalidConfig(
                format!("unsupported OPC UA security profile {policy:?}/{mode:?}").into(),
            ))
        }
    };
    Ok(endpoint)
}

#[cfg(any(feature = "opcua-wire", test))]
fn validate_security_profile(profile: &OpcUaSecurityProfile) -> Result<(), RuntimeError> {
    match (profile.policy, profile.mode) {
        (OpcUaSecurityPolicy::None, OpcUaMessageSecurityMode::None)
        | (OpcUaSecurityPolicy::Basic256Sha256, OpcUaMessageSecurityMode::Sign)
        | (OpcUaSecurityPolicy::Basic256Sha256, OpcUaMessageSecurityMode::SignAndEncrypt)
        | (OpcUaSecurityPolicy::Aes128Sha256RsaOaep, OpcUaMessageSecurityMode::Sign)
        | (OpcUaSecurityPolicy::Aes128Sha256RsaOaep, OpcUaMessageSecurityMode::SignAndEncrypt) => {
            Ok(())
        }
        (policy, mode) => Err(RuntimeError::InvalidConfig(
            format!("invalid runtime.opcua security profile {policy:?}/{mode:?}").into(),
        )),
    }
}

#[cfg(feature = "opcua-wire")]
fn normalize_endpoint_path(path: &str) -> Result<String, RuntimeError> {
    let trimmed = path.trim();
    if trimmed.is_empty() {
        return Ok("/".to_string());
    }
    if trimmed.starts_with('/') {
        return Ok(trimmed.to_string());
    }
    Err(RuntimeError::InvalidConfig(
        "runtime.opcua.endpoint_path must start with '/'".into(),
    ))
}

#[cfg(feature = "opcua-wire")]
fn parse_listen(listen: &str) -> Result<(String, u16), RuntimeError> {
    let trimmed = listen.trim();
    if trimmed.is_empty() {
        return Err(RuntimeError::InvalidConfig(
            "runtime.opcua.listen must not be empty".into(),
        ));
    }
    if let Ok(socket) = trimmed.parse::<std::net::SocketAddr>() {
        return Ok((socket.ip().to_string(), socket.port()));
    }
    let (host, port) = trimmed.rsplit_once(':').ok_or_else(|| {
        RuntimeError::InvalidConfig("runtime.opcua.listen must be host:port".into())
    })?;
    let host = host.trim().trim_start_matches('[').trim_end_matches(']');
    if host.is_empty() {
        return Err(RuntimeError::InvalidConfig(
            "runtime.opcua.listen host must not be empty".into(),
        ));
    }
    let port = port.parse::<u16>().map_err(|err| {
        RuntimeError::InvalidConfig(format!("invalid OPC UA listen port: {err}").into())
    })?;
    Ok((host.to_string(), port))
}

#[cfg(feature = "opcua-wire")]
fn wait_for_endpoint(host: &str, port: u16, timeout: StdDuration) -> Result<(), RuntimeError> {
    let deadline = Instant::now() + timeout;
    while Instant::now() < deadline {
        if std::net::TcpStream::connect((host, port)).is_ok() {
            return Ok(());
        }
        std::thread::sleep(StdDuration::from_millis(40));
    }
    Err(RuntimeError::ControlError(
        format!("OPC UA endpoint not reachable at {host}:{port}").into(),
    ))
}

#[cfg(feature = "opcua-wire")]
fn to_wire_security_policy(policy: OpcUaSecurityPolicy) -> ::opcua::crypto::SecurityPolicy {
    match policy {
        OpcUaSecurityPolicy::None => ::opcua::crypto::SecurityPolicy::None,
        OpcUaSecurityPolicy::Basic256Sha256 => ::opcua::crypto::SecurityPolicy::Basic256Sha256,
        OpcUaSecurityPolicy::Aes128Sha256RsaOaep => {
            ::opcua::crypto::SecurityPolicy::Aes128Sha256RsaOaep
        }
    }
}

#[cfg(feature = "opcua-wire")]
fn to_wire_security_mode(mode: OpcUaMessageSecurityMode) -> ::opcua::types::MessageSecurityMode {
    match mode {
        OpcUaMessageSecurityMode::None => ::opcua::types::MessageSecurityMode::None,
        OpcUaMessageSecurityMode::Sign => ::opcua::types::MessageSecurityMode::Sign,
        OpcUaMessageSecurityMode::SignAndEncrypt => {
            ::opcua::types::MessageSecurityMode::SignAndEncrypt
        }
    }
}

#[cfg(feature = "opcua-wire")]
fn to_wire_variant(value: &OpcUaVariant) -> ::opcua::types::Variant {
    match value {
        OpcUaVariant::Boolean(value) => ::opcua::types::Variant::Boolean(*value),
        OpcUaVariant::Int16(value) => ::opcua::types::Variant::Int16(*value),
        OpcUaVariant::Int32(value) => ::opcua::types::Variant::Int32(*value),
        OpcUaVariant::Int64(value) => ::opcua::types::Variant::Int64(*value),
        OpcUaVariant::UInt16(value) => ::opcua::types::Variant::UInt16(*value),
        OpcUaVariant::UInt32(value) => ::opcua::types::Variant::UInt32(*value),
        OpcUaVariant::UInt64(value) => ::opcua::types::Variant::UInt64(*value),
        OpcUaVariant::Float(value) => ::opcua::types::Variant::Float(*value),
        OpcUaVariant::Double(value) => ::opcua::types::Variant::Double(*value),
        OpcUaVariant::String(value) => ::opcua::types::Variant::String(value.as_str().into()),
    }
}

#[cfg(feature = "opcua-wire")]
fn from_wire_variant(value: &::opcua::types::Variant) -> Option<OpcUaVariant> {
    match value {
        ::opcua::types::Variant::Boolean(value) => Some(OpcUaVariant::Boolean(*value)),
        ::opcua::types::Variant::Int16(value) => Some(OpcUaVariant::Int16(*value)),
        ::opcua::types::Variant::Int32(value) => Some(OpcUaVariant::Int32(*value)),
        ::opcua::types::Variant::Int64(value) => Some(OpcUaVariant::Int64(*value)),
        ::opcua::types::Variant::UInt16(value) => Some(OpcUaVariant::UInt16(*value)),
        ::opcua::types::Variant::UInt32(value) => Some(OpcUaVariant::UInt32(*value)),
        ::opcua::types::Variant::UInt64(value) => Some(OpcUaVariant::UInt64(*value)),
        ::opcua::types::Variant::Float(value) => Some(OpcUaVariant::Float(*value)),
        ::opcua::types::Variant::Double(value) => Some(OpcUaVariant::Double(*value)),
        ::opcua::types::Variant::String(value) => Some(OpcUaVariant::String(value.to_string())),
        _ => None,
    }
}

#[cfg(feature = "opcua-wire")]
fn opcua_status_error(status: ::opcua::types::StatusCode) -> RuntimeError {
    RuntimeError::ControlError(format!("OPC UA status: {status}").into())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::value::Value;

    #[test]
    fn maps_scalar_numeric_and_string_types() {
        assert_eq!(
            map_iec_value(&Value::Bool(true)),
            Some(OpcUaValue {
                data_type: OpcUaDataType::Boolean,
                value: OpcUaVariant::Boolean(true),
            })
        );
        assert_eq!(
            map_iec_value(&Value::DInt(42)),
            Some(OpcUaValue {
                data_type: OpcUaDataType::Int32,
                value: OpcUaVariant::Int32(42),
            })
        );
        assert_eq!(
            map_iec_value(&Value::LReal(3.5)),
            Some(OpcUaValue {
                data_type: OpcUaDataType::Double,
                value: OpcUaVariant::Double(3.5),
            })
        );
        assert_eq!(
            map_iec_value(&Value::String(smol_str::SmolStr::new("Pump"))),
            Some(OpcUaValue {
                data_type: OpcUaDataType::String,
                value: OpcUaVariant::String("Pump".to_string()),
            })
        );
    }

    #[test]
    fn rejects_non_scalar_or_protocol_specific_types() {
        assert!(map_iec_value(&Value::Null).is_none());
        assert!(map_iec_value(&Value::Reference(None)).is_none());
        assert!(map_iec_value(&Value::Time(crate::value::Duration::from_millis(10))).is_none());
    }

    #[test]
    fn secure_profile_defaults_to_signed_and_encrypted_policy() {
        assert_eq!(
            OpcUaSecurityProfile::default(),
            OpcUaSecurityProfile {
                policy: OpcUaSecurityPolicy::Basic256Sha256,
                mode: OpcUaMessageSecurityMode::SignAndEncrypt,
                allow_anonymous: false,
            }
        );
    }

    #[test]
    fn parses_security_policy_and_mode_aliases() {
        assert_eq!(
            OpcUaSecurityPolicy::parse("basic256_sha256"),
            Some(OpcUaSecurityPolicy::Basic256Sha256)
        );
        assert_eq!(
            OpcUaSecurityPolicy::parse("Aes128-Sha256-RsaOaep"),
            Some(OpcUaSecurityPolicy::Aes128Sha256RsaOaep)
        );
        assert_eq!(
            OpcUaMessageSecurityMode::parse("sign_and_encrypt"),
            Some(OpcUaMessageSecurityMode::SignAndEncrypt)
        );
        assert_eq!(
            OpcUaMessageSecurityMode::parse("none"),
            Some(OpcUaMessageSecurityMode::None)
        );
    }

    #[test]
    fn rejects_invalid_security_profile_combinations() {
        let invalid = OpcUaSecurityProfile {
            policy: OpcUaSecurityPolicy::None,
            mode: OpcUaMessageSecurityMode::Sign,
            allow_anonymous: true,
        };
        assert!(validate_security_profile(&invalid).is_err());
    }
}
